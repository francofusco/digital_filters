<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>digital_filters: digital_filters::Filter&lt; DataType, CoeffType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">digital_filters
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdigital__filters_1_1Filter.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classdigital__filters_1_1Filter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">digital_filters::Filter&lt; DataType, CoeffType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Simple class that represents a digital filter.  
 <a href="classdigital__filters_1_1Filter.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="filter_8hpp_source.html">include/digital_filters/filter.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6c6f55f11621a7d868ce726e5a06b8e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdigital__filters_1_1Filter.html#a6c6f55f11621a7d868ce726e5a06b8e7">Filter</a> (const std::vector&lt; CoeffType &gt; &amp;b_num, const std::vector&lt; CoeffType &gt; &amp;a_den)</td></tr>
<tr class="memdesc:a6c6f55f11621a7d868ce726e5a06b8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a filter from given coefficients.  <a href="classdigital__filters_1_1Filter.html#a6c6f55f11621a7d868ce726e5a06b8e7">More...</a><br /></td></tr>
<tr class="separator:a6c6f55f11621a7d868ce726e5a06b8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f89a75a349df24392e95084f880ef59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdigital__filters_1_1Filter.html">Filter</a>&lt; DataType, CoeffType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdigital__filters_1_1Filter.html#a1f89a75a349df24392e95084f880ef59">operator*</a> (const <a class="el" href="classdigital__filters_1_1Filter.html">Filter</a>&lt; DataType, CoeffType &gt; &amp;other) const</td></tr>
<tr class="memdesc:a1f89a75a349df24392e95084f880ef59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters concatenation.  <a href="classdigital__filters_1_1Filter.html#a1f89a75a349df24392e95084f880ef59">More...</a><br /></td></tr>
<tr class="separator:a1f89a75a349df24392e95084f880ef59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150a4c9ca8ac471706b8d32091c9c469"><td class="memTemplParams" colspan="2">template&lt;class OtherDataType , class OtherCoeffType &gt; </td></tr>
<tr class="memitem:a150a4c9ca8ac471706b8d32091c9c469"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdigital__filters_1_1Filter.html">Filter</a>&lt; OtherDataType, OtherCoeffType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdigital__filters_1_1Filter.html#a150a4c9ca8ac471706b8d32091c9c469">as</a> () const</td></tr>
<tr class="memdesc:a150a4c9ca8ac471706b8d32091c9c469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change filter template types.  <a href="classdigital__filters_1_1Filter.html#a150a4c9ca8ac471706b8d32091c9c469">More...</a><br /></td></tr>
<tr class="separator:a150a4c9ca8ac471706b8d32091c9c469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa181750fbf11a757460dd478c8bfa8cb"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; CoeffType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdigital__filters_1_1Filter.html#aa181750fbf11a757460dd478c8bfa8cb">numerator</a> () const</td></tr>
<tr class="memdesc:aa181750fbf11a757460dd478c8bfa8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the numerator.  <a href="classdigital__filters_1_1Filter.html#aa181750fbf11a757460dd478c8bfa8cb">More...</a><br /></td></tr>
<tr class="separator:aa181750fbf11a757460dd478c8bfa8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c9f0bf92dfb7de893152b23eada66c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; CoeffType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdigital__filters_1_1Filter.html#a40c9f0bf92dfb7de893152b23eada66c">denominator</a> () const</td></tr>
<tr class="memdesc:a40c9f0bf92dfb7de893152b23eada66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the denominator.  <a href="classdigital__filters_1_1Filter.html#a40c9f0bf92dfb7de893152b23eada66c">More...</a><br /></td></tr>
<tr class="separator:a40c9f0bf92dfb7de893152b23eada66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26026ee07a16e353ffed277700ab2e58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdigital__filters_1_1Filter.html#a26026ee07a16e353ffed277700ab2e58">initInput</a> (const DataType &amp;input)</td></tr>
<tr class="memdesc:a26026ee07a16e353ffed277700ab2e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set initial conditions on the input.  <a href="classdigital__filters_1_1Filter.html#a26026ee07a16e353ffed277700ab2e58">More...</a><br /></td></tr>
<tr class="separator:a26026ee07a16e353ffed277700ab2e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce0cb092d7efb96792f5df3c59ec3ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdigital__filters_1_1Filter.html#a8ce0cb092d7efb96792f5df3c59ec3ec">initInput</a> (const std::vector&lt; DataType &gt; &amp;input)</td></tr>
<tr class="memdesc:a8ce0cb092d7efb96792f5df3c59ec3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set initial conditions on the input.  <a href="classdigital__filters_1_1Filter.html#a8ce0cb092d7efb96792f5df3c59ec3ec">More...</a><br /></td></tr>
<tr class="separator:a8ce0cb092d7efb96792f5df3c59ec3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb905476b5a9194895b107581869be3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdigital__filters_1_1Filter.html#a8eb905476b5a9194895b107581869be3">initOutput</a> (const DataType &amp;output)</td></tr>
<tr class="memdesc:a8eb905476b5a9194895b107581869be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set initial conditions on the output.  <a href="classdigital__filters_1_1Filter.html#a8eb905476b5a9194895b107581869be3">More...</a><br /></td></tr>
<tr class="separator:a8eb905476b5a9194895b107581869be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f961ecd770dd98208f08e8e6d708a29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdigital__filters_1_1Filter.html#a4f961ecd770dd98208f08e8e6d708a29">initOutput</a> (const std::vector&lt; DataType &gt; &amp;output)</td></tr>
<tr class="memdesc:a4f961ecd770dd98208f08e8e6d708a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set initial conditions on the output.  <a href="classdigital__filters_1_1Filter.html#a4f961ecd770dd98208f08e8e6d708a29">More...</a><br /></td></tr>
<tr class="separator:a4f961ecd770dd98208f08e8e6d708a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2c8670909207dab9c74981f2a11428"><td class="memItemLeft" align="right" valign="top">const DataType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdigital__filters_1_1Filter.html#abf2c8670909207dab9c74981f2a11428">filter</a> (const DataType &amp;x)</td></tr>
<tr class="memdesc:abf2c8670909207dab9c74981f2a11428"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdigital__filters_1_1Filter.html" title="Simple class that represents a digital filter.">Filter</a> the current input.  <a href="classdigital__filters_1_1Filter.html#abf2c8670909207dab9c74981f2a11428">More...</a><br /></td></tr>
<tr class="separator:abf2c8670909207dab9c74981f2a11428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e696aaec04d9dd7c3545a3d8cb84bfb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; DataType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdigital__filters_1_1Filter.html#a2e696aaec04d9dd7c3545a3d8cb84bfb">filter</a> (const std::vector&lt; DataType &gt; &amp;x0, const std::vector&lt; DataType &gt; &amp;y0, const std::vector&lt; DataType &gt; &amp;x) const</td></tr>
<tr class="memdesc:a2e696aaec04d9dd7c3545a3d8cb84bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdigital__filters_1_1Filter.html" title="Simple class that represents a digital filter.">Filter</a> a whole sequence.  <a href="classdigital__filters_1_1Filter.html#a2e696aaec04d9dd7c3545a3d8cb84bfb">More...</a><br /></td></tr>
<tr class="separator:a2e696aaec04d9dd7c3545a3d8cb84bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0418bba7c4f3dd124224cb5300c1f12f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; DataType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdigital__filters_1_1Filter.html#a0418bba7c4f3dd124224cb5300c1f12f">filter2</a> (const std::vector&lt; DataType &gt; &amp;x) const</td></tr>
<tr class="memdesc:a0418bba7c4f3dd124224cb5300c1f12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bi-directional filtering of a whole sequence.  <a href="classdigital__filters_1_1Filter.html#a0418bba7c4f3dd124224cb5300c1f12f">More...</a><br /></td></tr>
<tr class="separator:a0418bba7c4f3dd124224cb5300c1f12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a54191358d43d7b8ba22120ce08e9ac37"><td class="memItemLeft" align="right" valign="top">std::vector&lt; CoeffType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdigital__filters_1_1Filter.html#a54191358d43d7b8ba22120ce08e9ac37">b_</a></td></tr>
<tr class="memdesc:a54191358d43d7b8ba22120ce08e9ac37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerator of the transfer function.  <a href="classdigital__filters_1_1Filter.html#a54191358d43d7b8ba22120ce08e9ac37">More...</a><br /></td></tr>
<tr class="separator:a54191358d43d7b8ba22120ce08e9ac37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa16721d188119d9f59804c5298602d8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; CoeffType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdigital__filters_1_1Filter.html#afa16721d188119d9f59804c5298602d8">a_</a></td></tr>
<tr class="memdesc:afa16721d188119d9f59804c5298602d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denominator of the transfer function.  <a href="classdigital__filters_1_1Filter.html#afa16721d188119d9f59804c5298602d8">More...</a><br /></td></tr>
<tr class="separator:afa16721d188119d9f59804c5298602d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ac75bdcd74cff75dae291175bb8d60"><td class="memItemLeft" align="right" valign="top">std::deque&lt; DataType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdigital__filters_1_1Filter.html#af3ac75bdcd74cff75dae291175bb8d60">in_</a></td></tr>
<tr class="memdesc:af3ac75bdcd74cff75dae291175bb8d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input samples.  <a href="classdigital__filters_1_1Filter.html#af3ac75bdcd74cff75dae291175bb8d60">More...</a><br /></td></tr>
<tr class="separator:af3ac75bdcd74cff75dae291175bb8d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3094029502a747a8a769ef7f09d6f224"><td class="memItemLeft" align="right" valign="top">std::deque&lt; DataType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdigital__filters_1_1Filter.html#a3094029502a747a8a769ef7f09d6f224">out_</a></td></tr>
<tr class="memdesc:a3094029502a747a8a769ef7f09d6f224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output samples.  <a href="classdigital__filters_1_1Filter.html#a3094029502a747a8a769ef7f09d6f224">More...</a><br /></td></tr>
<tr class="separator:a3094029502a747a8a769ef7f09d6f224"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class DataType, class CoeffType&gt;<br />
class digital_filters::Filter&lt; DataType, CoeffType &gt;</h3>

<p>Simple class that represents a digital filter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>Type of the input/output signals </td></tr>
    <tr><td class="paramname">CoeffType</td><td>Type of the coefficients of the transfer function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Add a method to find initial conditions. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6c6f55f11621a7d868ce726e5a06b8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6f55f11621a7d868ce726e5a06b8e7">&#9670;&nbsp;</a></span>Filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType , class CoeffType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdigital__filters_1_1Filter.html">digital_filters::Filter</a>&lt; DataType, CoeffType &gt;::<a class="el" href="classdigital__filters_1_1Filter.html">Filter</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; CoeffType &gt; &amp;&#160;</td>
          <td class="paramname"><em>b_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CoeffType &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_den</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a filter from given coefficients. </p>
<p>Creates a filter whose transfer function in the discrete domain is given as: </p><p class="formulaDsp">
\[ H(z) = \frac{b(z)}{a(z)} = \frac{b_0 + b_1 z^{-1} + \cdots}{a_0 + a_1 z^{-1} + \cdots} \]
</p>
<p> which corresponds to the difference equation: </p><p class="formulaDsp">
\[ a_0 y_k + a_1 y_{k-1} + a_2 y_{k-2} + \cdots = b_0 x_k + b_1 x_{k-1} + b_2 x_{k-2} + \cdots \]
</p>
<p> The denominator will be normalized internally, i.e., each element of the denominator and numerator will be divided by \( a_0 \). This adds a requirement on the coefficients type: they must support operator/. In addition, this requires \( a_0 \) to be non-zero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b_num</td><td>Numerator of the discrete transfer function. Entries should be ordered such that <code>b_num[i]</code> contains \( b_i \). </td></tr>
    <tr><td class="paramname">a_den</td><td>Denominator of the discrete transfer function. Entries should be ordered such that <code>a_den[i]</code> contains \( a_i \). Note that the first element must not be zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a150a4c9ca8ac471706b8d32091c9c469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150a4c9ca8ac471706b8d32091c9c469">&#9670;&nbsp;</a></span>as()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType , class CoeffType &gt; </div>
<div class="memtemplate">
template&lt;class OtherDataType , class OtherCoeffType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdigital__filters_1_1Filter.html">Filter</a>&lt; OtherDataType, OtherCoeffType &gt; <a class="el" href="classdigital__filters_1_1Filter.html">digital_filters::Filter</a>&lt; DataType, CoeffType &gt;::as</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change filter template types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherDataType</td><td>new type of the input/output signals. </td></tr>
    <tr><td class="paramname">OtherCoeffType</td><td>new type of the coefficients. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new filter which is a copy of the current one, but with different template types. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>To perform the conversion, <code>static_cast</code> is used. Make sure that this is not an issue for your datatypes. </dd></dl>

</div>
</div>
<a id="a40c9f0bf92dfb7de893152b23eada66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c9f0bf92dfb7de893152b23eada66c">&#9670;&nbsp;</a></span>denominator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType , class CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;CoeffType&gt;&amp; <a class="el" href="classdigital__filters_1_1Filter.html">digital_filters::Filter</a>&lt; DataType, CoeffType &gt;::denominator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the denominator. </p>

</div>
</div>
<a id="abf2c8670909207dab9c74981f2a11428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2c8670909207dab9c74981f2a11428">&#9670;&nbsp;</a></span>filter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType , class CoeffType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const DataType &amp; <a class="el" href="classdigital__filters_1_1Filter.html">digital_filters::Filter</a>&lt; DataType, CoeffType &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classdigital__filters_1_1Filter.html" title="Simple class that represents a digital filter.">Filter</a> the current input. </p>

</div>
</div>
<a id="a2e696aaec04d9dd7c3545a3d8cb84bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e696aaec04d9dd7c3545a3d8cb84bfb">&#9670;&nbsp;</a></span>filter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType , class CoeffType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; DataType &gt; <a class="el" href="classdigital__filters_1_1Filter.html">digital_filters::Filter</a>&lt; DataType, CoeffType &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classdigital__filters_1_1Filter.html" title="Simple class that represents a digital filter.">Filter</a> a whole sequence. </p>
<p>Internal buffers will not be updated, meaning that the initial conditions of the filter will not change after calling this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input signal to be filtered. It should be sorted in time-ascending order, <em>i.e.</em>, so that <code>x[k]</code> corresponds to the discrete-time sample \( x_k \). </td></tr>
    <tr><td class="paramname">x0</td><td>initial input conditions. It should contain "past" input samples sorted in time-ascending order, <em>i.e.</em>, \( \cdots, x_{k-3}, x_{k-2}, x_{k-1} \) </td></tr>
    <tr><td class="paramname">y0</td><td>initial output conditions. It should contain "past" output samples sorted in time-ascending order, <em>i.e.</em>, \( \cdots, y_{-3}, y_{-2}, y_{-1} \) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sequence of filtered outputs \( y_0, y_1, y_2, \cdots \) </dd></dl>

</div>
</div>
<a id="a0418bba7c4f3dd124224cb5300c1f12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0418bba7c4f3dd124224cb5300c1f12f">&#9670;&nbsp;</a></span>filter2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType , class CoeffType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; DataType &gt; <a class="el" href="classdigital__filters_1_1Filter.html">digital_filters::Filter</a>&lt; DataType, CoeffType &gt;::filter2 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bi-directional filtering of a whole sequence. </p>
<p><a class="el" href="classdigital__filters_1_1Filter.html" title="Simple class that represents a digital filter.">Filter</a> a given signal from both sides by applying the filter once and then a second time on the reversed result. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input signal to be filtered. It should be sorted in time-ascending order, <em>i.e.</em>, so that <code>x[k]</code> corresponds to the discrete-time sample \( x_k \). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sequence of filtered outputs \( y_0, y_1, y_2, \cdots \) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>for the moment, the initial conditions are obtained by holding the signal on the left and on the right. </dd></dl>

</div>
</div>
<a id="a26026ee07a16e353ffed277700ab2e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26026ee07a16e353ffed277700ab2e58">&#9670;&nbsp;</a></span>initInput() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType , class CoeffType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdigital__filters_1_1Filter.html">digital_filters::Filter</a>&lt; DataType, CoeffType &gt;::initInput </td>
          <td>(</td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set initial conditions on the input. </p>
<p>To evaluate the output of the filter at the discrete time-step \( k \), it is necessary to use the past values of the input, <em>i.e.</em>, \( x_{k-1}, x_{k-2}, \cdots \). This function allows to set these conditions to a given value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>value \( x^\star \) to be used to initialize all samples, <em>i.e.</em>, \( x_{k}=x^\star, x_{k-1}=x^\star, x_{k-2}=x^\star, \cdots \). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ce0cb092d7efb96792f5df3c59ec3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce0cb092d7efb96792f5df3c59ec3ec">&#9670;&nbsp;</a></span>initInput() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType , class CoeffType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdigital__filters_1_1Filter.html">digital_filters::Filter</a>&lt; DataType, CoeffType &gt;::initInput </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set initial conditions on the input. </p>
<p>To evaluate the output of the filter at the discrete time-step \( k \), it is necessary to use the current and the past values of the input, <em>i.e.</em>, \( x_{k}, x_{k-1}, x_{k-2}, \cdots \). This function allows to set the past values of \(x\) (the current one will be set while calling <code><a class="el" href="classdigital__filters_1_1Filter.html#abf2c8670909207dab9c74981f2a11428" title="Filter the current input.">filter()</a></code>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>values \( \cdots, x_{k-2}, x_{k-1} \). Samples should be sorted in time-ascending order. In other words, the sequence starts with the oldest value and ends with the most recent sample. Note that the number of required values equals the dimension of the denominator minus one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8eb905476b5a9194895b107581869be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb905476b5a9194895b107581869be3">&#9670;&nbsp;</a></span>initOutput() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType , class CoeffType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdigital__filters_1_1Filter.html">digital_filters::Filter</a>&lt; DataType, CoeffType &gt;::initOutput </td>
          <td>(</td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set initial conditions on the output. </p>
<p>To evaluate the output of the filter at the discrete time-step \( k \), it is necessary to use the past values of the output, <em>i.e.</em>, \( y_{k-1}, y_{k-2}, \cdots \). This function allows to set these conditions to a given value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>value \( y^\star \) to be used to initialize all samples, <em>i.e.</em>, \( y_{k-1}=y^\star, y_{k-2}=y^\star, \cdots \). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f961ecd770dd98208f08e8e6d708a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f961ecd770dd98208f08e8e6d708a29">&#9670;&nbsp;</a></span>initOutput() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType , class CoeffType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdigital__filters_1_1Filter.html">digital_filters::Filter</a>&lt; DataType, CoeffType &gt;::initOutput </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set initial conditions on the output. </p>
<p>To evaluate the output of the filter at the discrete time-step \( k \), it is necessary to use the past values of the output, <em>i.e.</em>, \( y_{k-1}, y_{k-2}, \cdots \). This function allows to set the past values of \(y\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>values \( \cdots, y_{k-2}, y_{k-1} \). Samples should be sorted in time-ascending order. In other words, the sequence starts with the oldest value and ends with the most recent sample. Note that the number of required values equals the dimension of the denominator minus one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa181750fbf11a757460dd478c8bfa8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa181750fbf11a757460dd478c8bfa8cb">&#9670;&nbsp;</a></span>numerator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType , class CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;CoeffType&gt;&amp; <a class="el" href="classdigital__filters_1_1Filter.html">digital_filters::Filter</a>&lt; DataType, CoeffType &gt;::numerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the numerator. </p>

</div>
</div>
<a id="a1f89a75a349df24392e95084f880ef59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f89a75a349df24392e95084f880ef59">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType , class CoeffType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdigital__filters_1_1Filter.html">Filter</a>&lt; DataType, CoeffType &gt; <a class="el" href="classdigital__filters_1_1Filter.html">digital_filters::Filter</a>&lt; DataType, CoeffType &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdigital__filters_1_1Filter.html">Filter</a>&lt; DataType, CoeffType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters concatenation. </p>
<p>This overladed operator allows to concatenate two filters. Given the filters \(H_1(z)\) and \(H_2(z)\), the new filter \(H_3(z) = H_2(z)H_1(z)\) operates on a signal in the same way as filtering first with \(H_1(z)\) and then using \(H_2(z)\) (actually, the order of application of the two filters does not matter, since filter concatenation is a commutative operation). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>filter that should be concatenated to <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new filter which is the concatenation of <code>this</code> and <code>other</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afa16721d188119d9f59804c5298602d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa16721d188119d9f59804c5298602d8">&#9670;&nbsp;</a></span>a_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType , class CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;CoeffType&gt; <a class="el" href="classdigital__filters_1_1Filter.html">digital_filters::Filter</a>&lt; DataType, CoeffType &gt;::a_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Denominator of the transfer function. </p>

</div>
</div>
<a id="a54191358d43d7b8ba22120ce08e9ac37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54191358d43d7b8ba22120ce08e9ac37">&#9670;&nbsp;</a></span>b_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType , class CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;CoeffType&gt; <a class="el" href="classdigital__filters_1_1Filter.html">digital_filters::Filter</a>&lt; DataType, CoeffType &gt;::b_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Numerator of the transfer function. </p>

</div>
</div>
<a id="af3ac75bdcd74cff75dae291175bb8d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ac75bdcd74cff75dae291175bb8d60">&#9670;&nbsp;</a></span>in_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType , class CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;DataType&gt; <a class="el" href="classdigital__filters_1_1Filter.html">digital_filters::Filter</a>&lt; DataType, CoeffType &gt;::in_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Input samples. </p>

</div>
</div>
<a id="a3094029502a747a8a769ef7f09d6f224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3094029502a747a8a769ef7f09d6f224">&#9670;&nbsp;</a></span>out_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DataType , class CoeffType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;DataType&gt; <a class="el" href="classdigital__filters_1_1Filter.html">digital_filters::Filter</a>&lt; DataType, CoeffType &gt;::out_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output samples. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/digital_filters/<a class="el" href="filter_8hpp_source.html">filter.hpp</a></li>
<li>include/digital_filters/<a class="el" href="filter_8hxx_source.html">filter.hxx</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedigital__filters.html">digital_filters</a></li><li class="navelem"><a class="el" href="classdigital__filters_1_1Filter.html">Filter</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
